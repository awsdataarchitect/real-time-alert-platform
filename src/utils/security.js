/**\n * Security utility functions for the Real-Time Alert Platform\n */\n\nimport { fetchAuthSession } from 'aws-amplify/auth';\n\n/**\n * Sanitize user input to prevent XSS attacks\n * @param {string} input - User input to sanitize\n * @returns {string} Sanitized input\n */\nexport const sanitizeInput = (input) => {\n  if (typeof input !== 'string') {\n    return '';\n  }\n  \n  return input\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;')\n    .replace(/\\//g, '&#x2F;');\n};\n\n/**\n * Validate email format\n * @param {string} email - Email to validate\n * @returns {boolean} True if valid email format\n */\nexport const isValidEmail = (email) => {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n};\n\n/**\n * Validate password strength\n * @param {string} password - Password to validate\n * @returns {object} Validation result with isValid and errors\n */\nexport const validatePassword = (password) => {\n  const errors = [];\n  \n  if (!password || password.length < 8) {\n    errors.push('Password must be at least 8 characters long');\n  }\n  \n  if (!/[a-z]/.test(password)) {\n    errors.push('Password must contain at least one lowercase letter');\n  }\n  \n  if (!/[A-Z]/.test(password)) {\n    errors.push('Password must contain at least one uppercase letter');\n  }\n  \n  if (!/\\d/.test(password)) {\n    errors.push('Password must contain at least one number');\n  }\n  \n  if (!/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/.test(password)) {\n    errors.push('Password must contain at least one special character');\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n};\n\n/**\n * Generate a secure random string for API keys or tokens\n * @param {number} length - Length of the random string\n * @returns {string} Random string\n */\nexport const generateSecureRandomString = (length = 32) => {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  let result = '';\n  \n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  \n  return result;\n};\n\n/**\n * Check if the current session is still valid\n * @returns {Promise<boolean>} True if session is valid\n */\nexport const isSessionValid = async () => {\n  try {\n    const session = await fetchAuthSession();\n    const accessToken = session?.tokens?.accessToken;\n    \n    if (!accessToken) {\n      return false;\n    }\n    \n    // Check if token is expired\n    const currentTime = Math.floor(Date.now() / 1000);\n    const tokenExpiry = accessToken.payload.exp;\n    \n    return currentTime < tokenExpiry;\n  } catch (error) {\n    console.error('Error checking session validity:', error);\n    return false;\n  }\n};\n\n/**\n * Get user groups from the current session\n * @returns {Promise<string[]>} Array of user groups\n */\nexport const getUserGroups = async () => {\n  try {\n    const session = await fetchAuthSession();\n    const groups = session?.tokens?.accessToken?.payload?.['cognito:groups'] || [];\n    return Array.isArray(groups) ? groups : [];\n  } catch (error) {\n    console.error('Error getting user groups:', error);\n    return [];\n  }\n};\n\n/**\n * Get user ID from the current session\n * @returns {Promise<string|null>} User ID or null\n */\nexport const getUserId = async () => {\n  try {\n    const session = await fetchAuthSession();\n    return session?.tokens?.accessToken?.payload?.sub || null;\n  } catch (error) {\n    console.error('Error getting user ID:', error);\n    return null;\n  }\n};\n\n/**\n * Rate limiting utility for API calls\n */\nexport class RateLimiter {\n  constructor(maxRequests = 10, windowMs = 60000) {\n    this.maxRequests = maxRequests;\n    this.windowMs = windowMs;\n    this.requests = new Map();\n  }\n  \n  /**\n   * Check if a request is allowed\n   * @param {string} identifier - Unique identifier for the requester\n   * @returns {boolean} True if request is allowed\n   */\n  isAllowed(identifier) {\n    const now = Date.now();\n    const userRequests = this.requests.get(identifier) || [];\n    \n    // Remove old requests outside the window\n    const validRequests = userRequests.filter(time => now - time < this.windowMs);\n    \n    if (validRequests.length >= this.maxRequests) {\n      return false;\n    }\n    \n    // Add current request\n    validRequests.push(now);\n    this.requests.set(identifier, validRequests);\n    \n    return true;\n  }\n  \n  /**\n   * Get remaining requests for an identifier\n   * @param {string} identifier - Unique identifier for the requester\n   * @returns {number} Number of remaining requests\n   */\n  getRemainingRequests(identifier) {\n    const now = Date.now();\n    const userRequests = this.requests.get(identifier) || [];\n    const validRequests = userRequests.filter(time => now - time < this.windowMs);\n    \n    return Math.max(0, this.maxRequests - validRequests.length);\n  }\n}\n\n/**\n * Audit logging utility for security events\n */\nexport class SecurityAuditLogger {\n  constructor() {\n    this.logs = [];\n  }\n  \n  /**\n   * Log a security event\n   * @param {string} event - Event type\n   * @param {string} userId - User ID\n   * @param {object} details - Additional details\n   */\n  log(event, userId, details = {}) {\n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      event,\n      userId,\n      details,\n      userAgent: navigator.userAgent,\n      ip: 'client-side' // Would be populated server-side\n    };\n    \n    this.logs.push(logEntry);\n    \n    // In production, this would send to a secure logging service\n    if (process.env.REACT_APP_ENABLE_AUDIT_LOGGING === 'true') {\n      console.log('Security Event:', logEntry);\n    }\n  }\n  \n  /**\n   * Get audit logs (admin only)\n   * @returns {Array} Array of log entries\n   */\n  getLogs() {\n    return [...this.logs];\n  }\n  \n  /**\n   * Clear audit logs (admin only)\n   */\n  clearLogs() {\n    this.logs = [];\n  }\n}\n\n// Global instances\nexport const rateLimiter = new RateLimiter();\nexport const auditLogger = new SecurityAuditLogger();\n\n/**\n * Security event types for audit logging\n */\nexport const SECURITY_EVENTS = {\n  LOGIN_SUCCESS: 'LOGIN_SUCCESS',\n  LOGIN_FAILURE: 'LOGIN_FAILURE',\n  LOGOUT: 'LOGOUT',\n  REGISTRATION: 'REGISTRATION',\n  PASSWORD_CHANGE: 'PASSWORD_CHANGE',\n  UNAUTHORIZED_ACCESS: 'UNAUTHORIZED_ACCESS',\n  SESSION_EXPIRED: 'SESSION_EXPIRED',\n  SUSPICIOUS_ACTIVITY: 'SUSPICIOUS_ACTIVITY',\n  DATA_ACCESS: 'DATA_ACCESS',\n  DATA_MODIFICATION: 'DATA_MODIFICATION'\n};\n\n/**\n * Content Security Policy headers for enhanced security\n */\nexport const CSP_HEADERS = {\n  'Content-Security-Policy': [\n    \"default-src 'self'\",\n    \"script-src 'self' 'unsafe-inline' https://cognito-idp.*.amazonaws.com\",\n    \"style-src 'self' 'unsafe-inline'\",\n    \"img-src 'self' data: https:\",\n    \"connect-src 'self' https://*.amazonaws.com https://*.amazoncognito.com\",\n    \"font-src 'self'\",\n    \"object-src 'none'\",\n    \"media-src 'self'\",\n    \"frame-src 'none'\"\n  ].join('; ')\n};\n\n/**\n * Security headers for API responses\n */\nexport const SECURITY_HEADERS = {\n  'X-Content-Type-Options': 'nosniff',\n  'X-Frame-Options': 'DENY',\n  'X-XSS-Protection': '1; mode=block',\n  'Referrer-Policy': 'strict-origin-when-cross-origin',\n  'Permissions-Policy': 'geolocation=(), microphone=(), camera=()',\n  ...CSP_HEADERS\n};