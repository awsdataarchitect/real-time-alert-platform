/**\n * Integration tests for the complete authentication and authorization flow\n * These tests verify the end-to-end authentication experience\n */\n\nimport React from 'react';\nimport { render, screen, waitFor, act } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { BrowserRouter } from 'react-router-dom';\nimport App from '../../src/App';\nimport { getCurrentUser, signIn, signOut, signUp, confirmSignUp, fetchAuthSession } from 'aws-amplify/auth';\nimport { USER_ROLES } from '../../src/context/AuthContext';\n\n// Mock AWS Amplify Auth\njest.mock('aws-amplify/auth', () => ({\n  getCurrentUser: jest.fn(),\n  signIn: jest.fn(),\n  signOut: jest.fn(),\n  signUp: jest.fn(),\n  confirmSignUp: jest.fn(),\n  fetchAuthSession: jest.fn()\n}));\n\n// Mock the layout components to avoid complex rendering\njest.mock('../../src/components/layout/Header', () => {\n  return function MockHeader() {\n    return <div data-testid=\"header\">Header</div>;\n  };\n});\n\njest.mock('../../src/components/layout/Sidebar', () => {\n  return function MockSidebar() {\n    return <div data-testid=\"sidebar\">Sidebar</div>;\n  };\n});\n\n// Mock the page components\njest.mock('../../src/pages/Dashboard', () => {\n  return function MockDashboard() {\n    return <div data-testid=\"dashboard\">Dashboard</div>;\n  };\n});\n\njest.mock('../../src/pages/AlertDetailPage', () => {\n  return function MockAlertDetailPage() {\n    return <div data-testid=\"alert-detail\">Alert Detail</div>;\n  };\n});\n\njest.mock('../../src/pages/Settings', () => {\n  return function MockSettings() {\n    return <div data-testid=\"settings\">Settings</div>;\n  };\n});\n\n// Mock theme context\njest.mock('../../src/context/ThemeContext', () => ({\n  useTheme: () => ({ theme: 'light' })\n}));\n\nconst renderApp = () => {\n  return render(\n    <BrowserRouter>\n      <App />\n    </BrowserRouter>\n  );\n};\n\ndescribe('Authentication Flow Integration Tests', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    // Reset window location\n    delete window.location;\n    window.location = { reload: jest.fn() };\n  });\n\n  describe('Unauthenticated User Flow', () => {\n    it('should show login form when user is not authenticated', async () => {\n      getCurrentUser.mockRejectedValue(new Error('No user'));\n      \n      renderApp();\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('header')).toBeInTheDocument();\n        expect(screen.getByTestId('sidebar')).toBeInTheDocument();\n        // Should show login form instead of dashboard\n        expect(screen.getByLabelText(/username/i)).toBeInTheDocument();\n        expect(screen.getByLabelText(/password/i)).toBeInTheDocument();\n        expect(screen.queryByTestId('dashboard')).not.toBeInTheDocument();\n      });\n    });\n\n    it('should complete login flow and show dashboard', async () => {\n      const user = userEvent.setup();\n      \n      // Start unauthenticated\n      getCurrentUser.mockRejectedValue(new Error('No user'));\n      \n      renderApp();\n      \n      await waitFor(() => {\n        expect(screen.getByLabelText(/username/i)).toBeInTheDocument();\n      });\n      \n      // Mock successful login\n      signIn.mockResolvedValue({ isSignedIn: true });\n      const mockUser = { username: 'testuser' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.USER]\n            }\n          }\n        }\n      };\n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      // Fill in login form\n      await user.type(screen.getByLabelText(/username/i), 'testuser');\n      await user.type(screen.getByLabelText(/password/i), 'password123');\n      await user.click(screen.getByRole('button', { name: /sign in/i }));\n      \n      // Should call signIn\n      await waitFor(() => {\n        expect(signIn).toHaveBeenCalledWith({\n          username: 'testuser',\n          password: 'password123'\n        });\n      });\n      \n      // Should reload page (mocked)\n      expect(window.location.reload).toHaveBeenCalled();\n    });\n\n    it('should handle login errors gracefully', async () => {\n      const user = userEvent.setup();\n      \n      getCurrentUser.mockRejectedValue(new Error('No user'));\n      signIn.mockRejectedValue(new Error('Invalid credentials'));\n      \n      renderApp();\n      \n      await waitFor(() => {\n        expect(screen.getByLabelText(/username/i)).toBeInTheDocument();\n      });\n      \n      // Fill in login form with invalid credentials\n      await user.type(screen.getByLabelText(/username/i), 'testuser');\n      await user.type(screen.getByLabelText(/password/i), 'wrongpassword');\n      await user.click(screen.getByRole('button', { name: /sign in/i }));\n      \n      // Should show error message\n      await waitFor(() => {\n        expect(screen.getByText(/invalid credentials/i)).toBeInTheDocument();\n      });\n      \n      // Should still show login form\n      expect(screen.getByLabelText(/username/i)).toBeInTheDocument();\n      expect(screen.queryByTestId('dashboard')).not.toBeInTheDocument();\n    });\n  });\n\n  describe('Registration Flow', () => {\n    it('should switch to registration form', async () => {\n      const user = userEvent.setup();\n      \n      getCurrentUser.mockRejectedValue(new Error('No user'));\n      \n      renderApp();\n      \n      await waitFor(() => {\n        expect(screen.getByText(/don't have an account/i)).toBeInTheDocument();\n      });\n      \n      // Click switch to register\n      await user.click(screen.getByText(/don't have an account/i));\n      \n      // Should show registration form\n      await waitFor(() => {\n        expect(screen.getByLabelText(/full name/i)).toBeInTheDocument();\n        expect(screen.getByLabelText(/email/i)).toBeInTheDocument();\n        expect(screen.getByRole('button', { name: /create account/i })).toBeInTheDocument();\n      });\n    });\n\n    it('should handle registration with confirmation', async () => {\n      const user = userEvent.setup();\n      \n      getCurrentUser.mockRejectedValue(new Error('No user'));\n      signUp.mockResolvedValue({\n        isSignUpComplete: false,\n        userId: 'test-user-id',\n        nextStep: { signUpStep: 'CONFIRM_SIGN_UP' }\n      });\n      \n      renderApp();\n      \n      // Switch to registration\n      await waitFor(() => {\n        expect(screen.getByText(/don't have an account/i)).toBeInTheDocument();\n      });\n      await user.click(screen.getByText(/don't have an account/i));\n      \n      // Fill registration form\n      await waitFor(() => {\n        expect(screen.getByLabelText(/full name/i)).toBeInTheDocument();\n      });\n      \n      await user.type(screen.getByLabelText(/full name/i), 'Test User');\n      await user.type(screen.getByLabelText(/username/i), 'testuser');\n      await user.type(screen.getByLabelText(/email/i), 'test@example.com');\n      await user.type(screen.getByLabelText(/^password/i), 'password123');\n      await user.type(screen.getByLabelText(/confirm password/i), 'password123');\n      \n      await user.click(screen.getByRole('button', { name: /create account/i }));\n      \n      // Should call signUp\n      await waitFor(() => {\n        expect(signUp).toHaveBeenCalledWith({\n          username: 'testuser',\n          password: 'password123',\n          options: {\n            userAttributes: {\n              email: 'test@example.com',\n              name: 'Test User'\n            }\n          }\n        });\n      });\n      \n      // Should show confirmation form\n      await waitFor(() => {\n        expect(screen.getByText(/confirm your account/i)).toBeInTheDocument();\n        expect(screen.getByLabelText(/confirmation code/i)).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Authenticated User Flow', () => {\n    it('should show dashboard for authenticated regular user', async () => {\n      const mockUser = { username: 'testuser' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.USER]\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      renderApp();\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('dashboard')).toBeInTheDocument();\n        expect(screen.queryByLabelText(/username/i)).not.toBeInTheDocument();\n      });\n    });\n\n    it('should show dashboard for authenticated admin user', async () => {\n      const mockUser = { username: 'admin' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.ADMINISTRATOR]\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      renderApp();\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('dashboard')).toBeInTheDocument();\n        expect(screen.queryByLabelText(/username/i)).not.toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Session Management', () => {\n    it('should handle session expiration gracefully', async () => {\n      // Start with valid session\n      const mockUser = { username: 'testuser' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.USER]\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      renderApp();\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('dashboard')).toBeInTheDocument();\n      });\n      \n      // Simulate session expiration\n      getCurrentUser.mockRejectedValue(new Error('Session expired'));\n      \n      // This would typically be triggered by a failed API call\n      // For this test, we'll simulate a re-render that checks auth state\n      act(() => {\n        // Force a re-check of auth state\n        window.dispatchEvent(new Event('focus'));\n      });\n      \n      // Should eventually show login form\n      await waitFor(() => {\n        expect(screen.queryByTestId('dashboard')).not.toBeInTheDocument();\n      }, { timeout: 3000 });\n    });\n  });\n\n  describe('Loading States', () => {\n    it('should show loading state during authentication check', () => {\n      // Mock a slow authentication check\n      getCurrentUser.mockImplementation(() => new Promise(() => {}));\n      \n      renderApp();\n      \n      expect(screen.getByTestId('auth-loading')).toBeInTheDocument();\n      expect(screen.queryByTestId('dashboard')).not.toBeInTheDocument();\n      expect(screen.queryByLabelText(/username/i)).not.toBeInTheDocument();\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle network errors during authentication', async () => {\n      getCurrentUser.mockRejectedValue(new Error('Network error'));\n      \n      renderApp();\n      \n      // Should fall back to unauthenticated state\n      await waitFor(() => {\n        expect(screen.getByLabelText(/username/i)).toBeInTheDocument();\n        expect(screen.queryByTestId('dashboard')).not.toBeInTheDocument();\n      });\n    });\n\n    it('should handle malformed session data', async () => {\n      const mockUser = { username: 'testuser' };\n      const malformedSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              // Missing cognito:groups\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(malformedSession);\n      \n      renderApp();\n      \n      // Should still show dashboard but with guest role\n      await waitFor(() => {\n        expect(screen.getByTestId('dashboard')).toBeInTheDocument();\n      });\n    });\n  });\n});