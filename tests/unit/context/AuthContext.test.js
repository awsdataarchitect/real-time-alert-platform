import React from 'react';
import { render, screen, waitFor, act } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { AuthProvider, useAuth, USER_ROLES, PERMISSIONS } from '../../../src/context/AuthContext';
import { getCurrentUser, signIn, signOut, signUp, confirmSignUp, fetchAuthSession } from 'aws-amplify/auth';

// Mock AWS Amplify Auth
jest.mock('aws-amplify/auth', () => ({
  getCurrentUser: jest.fn(),
  signIn: jest.fn(),
  signOut: jest.fn(),
  signUp: jest.fn(),
  confirmSignUp: jest.fn(),
  fetchAuthSession: jest.fn()
}));

// Test component to access auth context
const TestComponent = () => {
  const auth = useAuth();
  return (
    <div>
      <div data-testid=\"authenticated\">{auth.isAuthenticated().toString()}</div>\n      <div data-testid=\"loading\">{auth.loading.toString()}</div>\n      <div data-testid=\"user-role\">{auth.getUserRole()}</div>\n      <div data-testid=\"is-admin\">{auth.isAdmin().toString()}</div>\n      <div data-testid=\"is-alert-manager\">{auth.isAlertManager().toString()}</div>\n      <div data-testid=\"has-read-alerts\">{auth.hasPermission(PERMISSIONS.READ_ALERTS).toString()}</div>\n      <div data-testid=\"has-create-alerts\">{auth.hasPermission(PERMISSIONS.CREATE_ALERTS).toString()}</div>\n      <button onClick={() => auth.login('testuser', 'password')}>Login</button>\n      <button onClick={() => auth.logout()}>Logout</button>\n      <button onClick={() => auth.register('testuser', 'password', 'test@example.com')}>Register</button>\n    </div>\n  );\n};\n\nconst renderWithAuth = (component) => {\n  return render(\n    <AuthProvider>\n      {component}\n    </AuthProvider>\n  );\n};\n\ndescribe('AuthContext', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('Initial State', () => {\n    it('should start with loading state', async () => {\n      getCurrentUser.mockRejectedValue(new Error('No user'));\n      \n      renderWithAuth(<TestComponent />);\n      \n      expect(screen.getByTestId('loading')).toHaveTextContent('true');\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('loading')).toHaveTextContent('false');\n      });\n    });\n\n    it('should set user as not authenticated when no current user', async () => {\n      getCurrentUser.mockRejectedValue(new Error('No user'));\n      \n      renderWithAuth(<TestComponent />);\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('authenticated')).toHaveTextContent('false');\n        expect(screen.getByTestId('user-role')).toHaveTextContent(USER_ROLES.GUEST);\n      });\n    });\n\n    it('should set user as authenticated when current user exists', async () => {\n      const mockUser = { username: 'testuser' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.USER]\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      renderWithAuth(<TestComponent />);\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('authenticated')).toHaveTextContent('true');\n        expect(screen.getByTestId('user-role')).toHaveTextContent(USER_ROLES.USER);\n      });\n    });\n  });\n\n  describe('Authentication Methods', () => {\n    it('should handle successful login', async () => {\n      const user = userEvent.setup();\n      getCurrentUser.mockRejectedValue(new Error('No user'));\n      signIn.mockResolvedValue({ isSignedIn: true });\n      \n      const mockUser = { username: 'testuser' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.USER]\n            }\n          }\n        }\n      };\n      \n      renderWithAuth(<TestComponent />);\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('authenticated')).toHaveTextContent('false');\n      });\n      \n      // Mock successful login\n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      await act(async () => {\n        await user.click(screen.getByText('Login'));\n      });\n      \n      expect(signIn).toHaveBeenCalledWith({\n        username: 'testuser',\n        password: 'password'\n      });\n    });\n\n    it('should handle failed login', async () => {\n      const user = userEvent.setup();\n      getCurrentUser.mockRejectedValue(new Error('No user'));\n      signIn.mockRejectedValue(new Error('Invalid credentials'));\n      \n      renderWithAuth(<TestComponent />);\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('authenticated')).toHaveTextContent('false');\n      });\n      \n      await act(async () => {\n        await user.click(screen.getByText('Login'));\n      });\n      \n      expect(signIn).toHaveBeenCalled();\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('authenticated')).toHaveTextContent('false');\n      });\n    });\n\n    it('should handle logout', async () => {\n      const user = userEvent.setup();\n      const mockUser = { username: 'testuser' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.USER]\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      signOut.mockResolvedValue();\n      \n      renderWithAuth(<TestComponent />);\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('authenticated')).toHaveTextContent('true');\n      });\n      \n      await act(async () => {\n        await user.click(screen.getByText('Logout'));\n      });\n      \n      expect(signOut).toHaveBeenCalled();\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('authenticated')).toHaveTextContent('false');\n      });\n    });\n\n    it('should handle registration', async () => {\n      const user = userEvent.setup();\n      getCurrentUser.mockRejectedValue(new Error('No user'));\n      signUp.mockResolvedValue({\n        isSignUpComplete: false,\n        userId: 'test-user-id',\n        nextStep: { signUpStep: 'CONFIRM_SIGN_UP' }\n      });\n      \n      renderWithAuth(<TestComponent />);\n      \n      await act(async () => {\n        await user.click(screen.getByText('Register'));\n      });\n      \n      expect(signUp).toHaveBeenCalledWith({\n        username: 'testuser',\n        password: 'password',\n        options: {\n          userAttributes: {\n            email: 'test@example.com'\n          }\n        }\n      });\n    });\n  });\n\n  describe('Authorization Methods', () => {\n    it('should correctly identify admin users', async () => {\n      const mockUser = { username: 'admin' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.ADMINISTRATOR]\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      renderWithAuth(<TestComponent />);\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('is-admin')).toHaveTextContent('true');\n        expect(screen.getByTestId('user-role')).toHaveTextContent(USER_ROLES.ADMINISTRATOR);\n        expect(screen.getByTestId('has-create-alerts')).toHaveTextContent('true');\n      });\n    });\n\n    it('should correctly identify alert managers', async () => {\n      const mockUser = { username: 'manager' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.ALERT_MANAGER]\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      renderWithAuth(<TestComponent />);\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('is-alert-manager')).toHaveTextContent('true');\n        expect(screen.getByTestId('user-role')).toHaveTextContent(USER_ROLES.ALERT_MANAGER);\n        expect(screen.getByTestId('has-create-alerts')).toHaveTextContent('true');\n      });\n    });\n\n    it('should correctly identify regular users', async () => {\n      const mockUser = { username: 'user' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.USER]\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      renderWithAuth(<TestComponent />);\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('is-admin')).toHaveTextContent('false');\n        expect(screen.getByTestId('is-alert-manager')).toHaveTextContent('false');\n        expect(screen.getByTestId('user-role')).toHaveTextContent(USER_ROLES.USER);\n        expect(screen.getByTestId('has-read-alerts')).toHaveTextContent('true');\n        expect(screen.getByTestId('has-create-alerts')).toHaveTextContent('false');\n      });\n    });\n\n    it('should handle users with no groups as guests', async () => {\n      const mockUser = { username: 'guest' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': []\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      renderWithAuth(<TestComponent />);\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('user-role')).toHaveTextContent(USER_ROLES.GUEST);\n        expect(screen.getByTestId('has-read-alerts')).toHaveTextContent('false');\n      });\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle authentication errors gracefully', async () => {\n      getCurrentUser.mockRejectedValue(new Error('Network error'));\n      \n      renderWithAuth(<TestComponent />);\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('authenticated')).toHaveTextContent('false');\n        expect(screen.getByTestId('loading')).toHaveTextContent('false');\n      });\n    });\n\n    it('should handle session fetch errors', async () => {\n      const mockUser = { username: 'testuser' };\n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockRejectedValue(new Error('Session error'));\n      \n      renderWithAuth(<TestComponent />);\n      \n      await waitFor(() => {\n        expect(screen.getByTestId('authenticated')).toHaveTextContent('true');\n        expect(screen.getByTestId('user-role')).toHaveTextContent(USER_ROLES.GUEST);\n      });\n    });\n  });\n});