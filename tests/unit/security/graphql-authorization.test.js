/**\n * Security tests for GraphQL authorization directives\n * These tests verify that the GraphQL schema properly enforces\n * authentication and authorization rules\n */\n\nimport { USER_ROLES, PERMISSIONS } from '../../../src/context/AuthContext';\n\n// Mock GraphQL operations for testing authorization\nconst mockGraphQLOperations = {\n  // Alert operations\n  createAlert: {\n    operation: 'mutation',\n    name: 'createAlert',\n    requiredGroups: ['Administrators', 'AlertManagers'],\n    requiredAuth: true\n  },\n  updateAlert: {\n    operation: 'mutation',\n    name: 'updateAlert',\n    requiredGroups: ['Administrators', 'AlertManagers'],\n    requiredAuth: true\n  },\n  deleteAlert: {\n    operation: 'mutation',\n    name: 'deleteAlert',\n    requiredGroups: ['Administrators', 'AlertManagers'],\n    requiredAuth: true\n  },\n  getAlert: {\n    operation: 'query',\n    name: 'getAlert',\n    requiredGroups: [],\n    requiredAuth: false, // Public read access\n    allowPrivate: true\n  },\n  listAlerts: {\n    operation: 'query',\n    name: 'listAlerts',\n    requiredGroups: [],\n    requiredAuth: false, // Public read access\n    allowPrivate: true\n  },\n  \n  // User operations\n  createUser: {\n    operation: 'mutation',\n    name: 'createUser',\n    requiredGroups: [],\n    requiredAuth: true, // Private or admin\n    allowPrivate: true,\n    allowGroups: ['Administrators']\n  },\n  updateUser: {\n    operation: 'mutation',\n    name: 'updateUser',\n    requiredGroups: [],\n    requiredAuth: true,\n    ownerField: 'id',\n    allowGroups: ['Administrators']\n  },\n  deleteUser: {\n    operation: 'mutation',\n    name: 'deleteUser',\n    requiredGroups: [],\n    requiredAuth: true,\n    ownerField: 'id',\n    allowGroups: ['Administrators']\n  },\n  getUser: {\n    operation: 'query',\n    name: 'getUser',\n    requiredGroups: [],\n    requiredAuth: true,\n    ownerField: 'id',\n    allowGroups: ['Administrators']\n  },\n  listUsers: {\n    operation: 'query',\n    name: 'listUsers',\n    requiredGroups: ['Administrators'],\n    requiredAuth: true\n  },\n  \n  // DeliveryStatus operations\n  createDeliveryStatus: {\n    operation: 'mutation',\n    name: 'createDeliveryStatus',\n    requiredGroups: ['Administrators', 'AlertManagers'],\n    requiredAuth: true\n  },\n  updateDeliveryStatus: {\n    operation: 'mutation',\n    name: 'updateDeliveryStatus',\n    requiredGroups: [],\n    requiredAuth: true,\n    ownerField: 'userId',\n    allowGroups: ['Administrators', 'AlertManagers']\n  },\n  acknowledgeAlert: {\n    operation: 'mutation',\n    name: 'acknowledgeAlert',\n    requiredGroups: [],\n    requiredAuth: true,\n    ownerField: 'userId'\n  },\n  \n  // Webhook operations (special case - public with API key)\n  ingestWebhookAlert: {\n    operation: 'mutation',\n    name: 'ingestWebhookAlert',\n    requiredGroups: [],\n    requiredAuth: false, // Public but requires API key\n    requiresApiKey: true\n  }\n};\n\n// Mock user contexts for testing\nconst mockUserContexts = {\n  anonymous: {\n    authenticated: false,\n    groups: [],\n    userId: null\n  },\n  regularUser: {\n    authenticated: true,\n    groups: [USER_ROLES.USER],\n    userId: 'user-123'\n  },\n  alertManager: {\n    authenticated: true,\n    groups: [USER_ROLES.ALERT_MANAGER],\n    userId: 'manager-123'\n  },\n  administrator: {\n    authenticated: true,\n    groups: [USER_ROLES.ADMINISTRATOR],\n    userId: 'admin-123'\n  },\n  multiRole: {\n    authenticated: true,\n    groups: [USER_ROLES.USER, USER_ROLES.ALERT_MANAGER],\n    userId: 'multi-123'\n  }\n};\n\n/**\n * Helper function to check if a user context should have access to an operation\n */\nfunction shouldHaveAccess(operation, userContext, resourceOwnerId = null, apiKey = null) {\n  const op = mockGraphQLOperations[operation];\n  if (!op) return false;\n  \n  // Check if authentication is required\n  if (op.requiredAuth && !userContext.authenticated) {\n    return false;\n  }\n  \n  // Check API key requirement (for webhook operations)\n  if (op.requiresApiKey && !apiKey) {\n    return false;\n  }\n  \n  // If no authentication required and no groups required, allow access\n  if (!op.requiredAuth && op.requiredGroups.length === 0) {\n    return true;\n  }\n  \n  // Check group-based access\n  if (op.requiredGroups.length > 0) {\n    const hasRequiredGroup = op.requiredGroups.some(group => \n      userContext.groups.includes(group)\n    );\n    if (hasRequiredGroup) return true;\n  }\n  \n  // Check owner-based access\n  if (op.ownerField && resourceOwnerId === userContext.userId) {\n    return true;\n  }\n  \n  // Check if user has admin privileges (admins can access most things)\n  if (op.allowGroups && op.allowGroups.some(group => \n    userContext.groups.includes(group)\n  )) {\n    return true;\n  }\n  \n  // Check private access (authenticated users)\n  if (op.allowPrivate && userContext.authenticated) {\n    return true;\n  }\n  \n  return false;\n}\n\ndescribe('GraphQL Authorization Security Tests', () => {\n  describe('Alert Operations Authorization', () => {\n    test('anonymous users can read alerts but not modify them', () => {\n      const anonymous = mockUserContexts.anonymous;\n      \n      // Should be able to read\n      expect(shouldHaveAccess('getAlert', anonymous)).toBe(true);\n      expect(shouldHaveAccess('listAlerts', anonymous)).toBe(true);\n      \n      // Should not be able to modify\n      expect(shouldHaveAccess('createAlert', anonymous)).toBe(false);\n      expect(shouldHaveAccess('updateAlert', anonymous)).toBe(false);\n      expect(shouldHaveAccess('deleteAlert', anonymous)).toBe(false);\n    });\n    \n    test('regular users can read alerts but not modify them', () => {\n      const user = mockUserContexts.regularUser;\n      \n      // Should be able to read\n      expect(shouldHaveAccess('getAlert', user)).toBe(true);\n      expect(shouldHaveAccess('listAlerts', user)).toBe(true);\n      \n      // Should not be able to modify\n      expect(shouldHaveAccess('createAlert', user)).toBe(false);\n      expect(shouldHaveAccess('updateAlert', user)).toBe(false);\n      expect(shouldHaveAccess('deleteAlert', user)).toBe(false);\n    });\n    \n    test('alert managers can read and modify alerts', () => {\n      const manager = mockUserContexts.alertManager;\n      \n      // Should be able to read\n      expect(shouldHaveAccess('getAlert', manager)).toBe(true);\n      expect(shouldHaveAccess('listAlerts', manager)).toBe(true);\n      \n      // Should be able to modify\n      expect(shouldHaveAccess('createAlert', manager)).toBe(true);\n      expect(shouldHaveAccess('updateAlert', manager)).toBe(true);\n      expect(shouldHaveAccess('deleteAlert', manager)).toBe(true);\n    });\n    \n    test('administrators can read and modify alerts', () => {\n      const admin = mockUserContexts.administrator;\n      \n      // Should be able to read\n      expect(shouldHaveAccess('getAlert', admin)).toBe(true);\n      expect(shouldHaveAccess('listAlerts', admin)).toBe(true);\n      \n      // Should be able to modify\n      expect(shouldHaveAccess('createAlert', admin)).toBe(true);\n      expect(shouldHaveAccess('updateAlert', admin)).toBe(true);\n      expect(shouldHaveAccess('deleteAlert', admin)).toBe(true);\n    });\n  });\n  \n  describe('User Operations Authorization', () => {\n    test('anonymous users cannot access user operations', () => {\n      const anonymous = mockUserContexts.anonymous;\n      \n      expect(shouldHaveAccess('createUser', anonymous)).toBe(false);\n      expect(shouldHaveAccess('updateUser', anonymous)).toBe(false);\n      expect(shouldHaveAccess('deleteUser', anonymous)).toBe(false);\n      expect(shouldHaveAccess('getUser', anonymous)).toBe(false);\n      expect(shouldHaveAccess('listUsers', anonymous)).toBe(false);\n    });\n    \n    test('users can manage their own profile', () => {\n      const user = mockUserContexts.regularUser;\n      \n      // Should be able to create user (registration)\n      expect(shouldHaveAccess('createUser', user)).toBe(true);\n      \n      // Should be able to manage own profile\n      expect(shouldHaveAccess('updateUser', user, user.userId)).toBe(true);\n      expect(shouldHaveAccess('deleteUser', user, user.userId)).toBe(true);\n      expect(shouldHaveAccess('getUser', user, user.userId)).toBe(true);\n      \n      // Should not be able to manage other users\n      expect(shouldHaveAccess('updateUser', user, 'other-user-id')).toBe(false);\n      expect(shouldHaveAccess('deleteUser', user, 'other-user-id')).toBe(false);\n      expect(shouldHaveAccess('getUser', user, 'other-user-id')).toBe(false);\n      \n      // Should not be able to list all users\n      expect(shouldHaveAccess('listUsers', user)).toBe(false);\n    });\n    \n    test('administrators can manage all users', () => {\n      const admin = mockUserContexts.administrator;\n      \n      // Should be able to perform all user operations\n      expect(shouldHaveAccess('createUser', admin)).toBe(true);\n      expect(shouldHaveAccess('updateUser', admin, 'any-user-id')).toBe(true);\n      expect(shouldHaveAccess('deleteUser', admin, 'any-user-id')).toBe(true);\n      expect(shouldHaveAccess('getUser', admin, 'any-user-id')).toBe(true);\n      expect(shouldHaveAccess('listUsers', admin)).toBe(true);\n    });\n  });\n  \n  describe('Delivery Status Authorization', () => {\n    test('users can only manage their own delivery status', () => {\n      const user = mockUserContexts.regularUser;\n      \n      // Should not be able to create delivery status (system operation)\n      expect(shouldHaveAccess('createDeliveryStatus', user)).toBe(false);\n      \n      // Should be able to update own delivery status\n      expect(shouldHaveAccess('updateDeliveryStatus', user, user.userId)).toBe(true);\n      expect(shouldHaveAccess('acknowledgeAlert', user, user.userId)).toBe(true);\n      \n      // Should not be able to update others' delivery status\n      expect(shouldHaveAccess('updateDeliveryStatus', user, 'other-user-id')).toBe(false);\n      expect(shouldHaveAccess('acknowledgeAlert', user, 'other-user-id')).toBe(false);\n    });\n    \n    test('alert managers can manage delivery status', () => {\n      const manager = mockUserContexts.alertManager;\n      \n      // Should be able to create and manage delivery status\n      expect(shouldHaveAccess('createDeliveryStatus', manager)).toBe(true);\n      expect(shouldHaveAccess('updateDeliveryStatus', manager, 'any-user-id')).toBe(true);\n      \n      // Should be able to acknowledge for any user (admin operation)\n      expect(shouldHaveAccess('acknowledgeAlert', manager, manager.userId)).toBe(true);\n    });\n  });\n  \n  describe('Webhook Operations Authorization', () => {\n    test('webhook operations require API key', () => {\n      const anonymous = mockUserContexts.anonymous;\n      \n      // Should fail without API key\n      expect(shouldHaveAccess('ingestWebhookAlert', anonymous)).toBe(false);\n      \n      // Should succeed with API key\n      expect(shouldHaveAccess('ingestWebhookAlert', anonymous, null, 'valid-api-key')).toBe(true);\n    });\n    \n    test('authenticated users still need API key for webhook operations', () => {\n      const user = mockUserContexts.regularUser;\n      \n      // Should fail without API key even if authenticated\n      expect(shouldHaveAccess('ingestWebhookAlert', user)).toBe(false);\n      \n      // Should succeed with API key\n      expect(shouldHaveAccess('ingestWebhookAlert', user, null, 'valid-api-key')).toBe(true);\n    });\n  });\n  \n  describe('Multi-Role Users', () => {\n    test('users with multiple roles get combined permissions', () => {\n      const multiRole = mockUserContexts.multiRole;\n      \n      // Should have alert manager permissions\n      expect(shouldHaveAccess('createAlert', multiRole)).toBe(true);\n      expect(shouldHaveAccess('updateAlert', multiRole)).toBe(true);\n      expect(shouldHaveAccess('deleteAlert', multiRole)).toBe(true);\n      \n      // Should have user permissions\n      expect(shouldHaveAccess('getAlert', multiRole)).toBe(true);\n      expect(shouldHaveAccess('listAlerts', multiRole)).toBe(true);\n      \n      // Should be able to manage own profile\n      expect(shouldHaveAccess('updateUser', multiRole, multiRole.userId)).toBe(true);\n    });\n  });\n  \n  describe('Edge Cases and Security Boundaries', () => {\n    test('null or undefined user contexts are treated as anonymous', () => {\n      const nullUser = null;\n      const undefinedUser = undefined;\n      const emptyUser = {};\n      \n      // All should be treated as anonymous (no access to protected operations)\n      [nullUser, undefinedUser, emptyUser].forEach(user => {\n        const context = user || { authenticated: false, groups: [], userId: null };\n        expect(shouldHaveAccess('createAlert', context)).toBe(false);\n        expect(shouldHaveAccess('updateUser', context)).toBe(false);\n        expect(shouldHaveAccess('listUsers', context)).toBe(false);\n      });\n    });\n    \n    test('malformed group arrays are handled safely', () => {\n      const malformedUser = {\n        authenticated: true,\n        groups: null, // This should not cause errors\n        userId: 'user-123'\n      };\n      \n      // Should not have access to protected operations\n      expect(shouldHaveAccess('createAlert', malformedUser)).toBe(false);\n      expect(shouldHaveAccess('listUsers', malformedUser)).toBe(false);\n    });\n    \n    test('case sensitivity in role names', () => {\n      const caseUser = {\n        authenticated: true,\n        groups: ['administrators'], // lowercase\n        userId: 'user-123'\n      };\n      \n      // Should not have access (case sensitive)\n      expect(shouldHaveAccess('createAlert', caseUser)).toBe(false);\n      expect(shouldHaveAccess('listUsers', caseUser)).toBe(false);\n    });\n    \n    test('empty string API keys are not valid', () => {\n      const anonymous = mockUserContexts.anonymous;\n      \n      expect(shouldHaveAccess('ingestWebhookAlert', anonymous, null, '')).toBe(false);\n      expect(shouldHaveAccess('ingestWebhookAlert', anonymous, null, null)).toBe(false);\n      expect(shouldHaveAccess('ingestWebhookAlert', anonymous, null, undefined)).toBe(false);\n    });\n  });\n});