import React from 'react';\nimport { render, screen, waitFor } from '@testing-library/react';\nimport ProtectedRoute from '../../../../src/components/auth/ProtectedRoute';\nimport { AuthProvider, USER_ROLES, PERMISSIONS } from '../../../../src/context/AuthContext';\nimport { getCurrentUser, fetchAuthSession } from 'aws-amplify/auth';\n\n// Mock AWS Amplify Auth\njest.mock('aws-amplify/auth', () => ({\n  getCurrentUser: jest.fn(),\n  signIn: jest.fn(),\n  signOut: jest.fn(),\n  signUp: jest.fn(),\n  confirmSignUp: jest.fn(),\n  fetchAuthSession: jest.fn()\n}));\n\nconst TestComponent = () => <div data-testid=\"protected-content\">Protected Content</div>;\n\nconst renderWithAuth = (component) => {\n  return render(\n    <AuthProvider>\n      {component}\n    </AuthProvider>\n  );\n};\n\ndescribe('ProtectedRoute', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('Loading State', () => {\n    it('should show loading spinner while checking authentication', () => {\n      // Mock a slow auth check\n      getCurrentUser.mockImplementation(() => new Promise(() => {}));\n      \n      renderWithAuth(\n        <ProtectedRoute>\n          <TestComponent />\n        </ProtectedRoute>\n      );\n\n      expect(screen.getByTestId('auth-loading')).toBeInTheDocument();\n      expect(screen.queryByTestId('protected-content')).not.toBeInTheDocument();\n    });\n  });\n\n  describe('Public Access', () => {\n    it('should render children when requireAuth is false', async () => {\n      getCurrentUser.mockRejectedValue(new Error('No user'));\n      \n      renderWithAuth(\n        <ProtectedRoute requireAuth={false}>\n          <TestComponent />\n        </ProtectedRoute>\n      );\n\n      await waitFor(() => {\n        expect(screen.getByTestId('protected-content')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Authentication Required', () => {\n    it('should show login form when user is not authenticated', async () => {\n      getCurrentUser.mockRejectedValue(new Error('No user'));\n      \n      renderWithAuth(\n        <ProtectedRoute requireAuth={true}>\n          <TestComponent />\n        </ProtectedRoute>\n      );\n\n      await waitFor(() => {\n        expect(screen.queryByTestId('protected-content')).not.toBeInTheDocument();\n        // Should show login form (we can check for username input as a proxy)\n        expect(screen.getByLabelText(/username/i)).toBeInTheDocument();\n      });\n    });\n\n    it('should render children when user is authenticated', async () => {\n      const mockUser = { username: 'testuser' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.USER]\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      renderWithAuth(\n        <ProtectedRoute requireAuth={true}>\n          <TestComponent />\n        </ProtectedRoute>\n      );\n\n      await waitFor(() => {\n        expect(screen.getByTestId('protected-content')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Role-Based Access Control', () => {\n    it('should deny access when user lacks required role', async () => {\n      const mockUser = { username: 'testuser' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.USER]\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      renderWithAuth(\n        <ProtectedRoute \n          requireAuth={true} \n          requiredRoles={[USER_ROLES.ADMINISTRATOR]}\n        >\n          <TestComponent />\n        </ProtectedRoute>\n      );\n\n      await waitFor(() => {\n        expect(screen.getByTestId('access-denied')).toBeInTheDocument();\n        expect(screen.queryByTestId('protected-content')).not.toBeInTheDocument();\n        expect(screen.getByText(/access denied/i)).toBeInTheDocument();\n      });\n    });\n\n    it('should allow access when user has required role', async () => {\n      const mockUser = { username: 'admin' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.ADMINISTRATOR]\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      renderWithAuth(\n        <ProtectedRoute \n          requireAuth={true} \n          requiredRoles={[USER_ROLES.ADMINISTRATOR]}\n        >\n          <TestComponent />\n        </ProtectedRoute>\n      );\n\n      await waitFor(() => {\n        expect(screen.getByTestId('protected-content')).toBeInTheDocument();\n        expect(screen.queryByTestId('access-denied')).not.toBeInTheDocument();\n      });\n    });\n\n    it('should allow access when user has any of the required roles', async () => {\n      const mockUser = { username: 'manager' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.ALERT_MANAGER]\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      renderWithAuth(\n        <ProtectedRoute \n          requireAuth={true} \n          requiredRoles={[USER_ROLES.ADMINISTRATOR, USER_ROLES.ALERT_MANAGER]}\n        >\n          <TestComponent />\n        </ProtectedRoute>\n      );\n\n      await waitFor(() => {\n        expect(screen.getByTestId('protected-content')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Permission-Based Access Control', () => {\n    it('should deny access when user lacks required permission', async () => {\n      const mockUser = { username: 'testuser' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.USER]\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      renderWithAuth(\n        <ProtectedRoute \n          requireAuth={true} \n          requiredPermissions={[PERMISSIONS.CREATE_ALERTS]}\n        >\n          <TestComponent />\n        </ProtectedRoute>\n      );\n\n      await waitFor(() => {\n        expect(screen.getByTestId('access-denied')).toBeInTheDocument();\n        expect(screen.queryByTestId('protected-content')).not.toBeInTheDocument();\n      });\n    });\n\n    it('should allow access when user has required permission', async () => {\n      const mockUser = { username: 'admin' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.ADMINISTRATOR]\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      renderWithAuth(\n        <ProtectedRoute \n          requireAuth={true} \n          requiredPermissions={[PERMISSIONS.CREATE_ALERTS]}\n        >\n          <TestComponent />\n        </ProtectedRoute>\n      );\n\n      await waitFor(() => {\n        expect(screen.getByTestId('protected-content')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Fallback Content', () => {\n    it('should render fallback content when access is denied', async () => {\n      const mockUser = { username: 'testuser' };\n      const mockSession = {\n        tokens: {\n          accessToken: {\n            payload: {\n              'cognito:groups': [USER_ROLES.USER]\n            }\n          }\n        }\n      };\n      \n      getCurrentUser.mockResolvedValue(mockUser);\n      fetchAuthSession.mockResolvedValue(mockSession);\n      \n      const fallback = <div data-testid=\"fallback-content\">Fallback Content</div>;\n      \n      renderWithAuth(\n        <ProtectedRoute \n          requireAuth={true} \n          requiredRoles={[USER_ROLES.ADMINISTRATOR]}\n          fallback={fallback}\n        >\n          <TestComponent />\n        </ProtectedRoute>\n      );\n\n      await waitFor(() => {\n        expect(screen.getByTestId('access-denied')).toBeInTheDocument();\n        expect(screen.getByTestId('fallback-content')).toBeInTheDocument();\n        expect(screen.queryByTestId('protected-content')).not.toBeInTheDocument();\n      });\n    });\n  });\n});