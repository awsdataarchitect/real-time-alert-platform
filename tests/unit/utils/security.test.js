import {\n  sanitizeInput,\n  isValidEmail,\n  validatePassword,\n  generateSecureRandomString,\n  RateLimiter,\n  SecurityAuditLogger,\n  SECURITY_EVENTS\n} from '../../../src/utils/security';\n\ndescribe('Security Utilities', () => {\n  describe('sanitizeInput', () => {\n    it('should sanitize HTML characters', () => {\n      const maliciousInput = '<script>alert(\"XSS\")</script>';\n      const sanitized = sanitizeInput(maliciousInput);\n      expect(sanitized).toBe('&lt;script&gt;alert(&quot;XSS&quot;)&lt;&#x2F;script&gt;');\n    });\n\n    it('should handle ampersands', () => {\n      expect(sanitizeInput('Tom & Jerry')).toBe('Tom &amp; Jerry');\n    });\n\n    it('should handle quotes', () => {\n      expect(sanitizeInput('He said \"Hello\"')).toBe('He said &quot;Hello&quot;');\n      expect(sanitizeInput(\"It's working\")).toBe('It&#x27;s working');\n    });\n\n    it('should handle non-string input', () => {\n      expect(sanitizeInput(null)).toBe('');\n      expect(sanitizeInput(undefined)).toBe('');\n      expect(sanitizeInput(123)).toBe('');\n      expect(sanitizeInput({})).toBe('');\n    });\n\n    it('should handle empty string', () => {\n      expect(sanitizeInput('')).toBe('');\n    });\n  });\n\n  describe('isValidEmail', () => {\n    it('should validate correct email formats', () => {\n      expect(isValidEmail('user@example.com')).toBe(true);\n      expect(isValidEmail('test.email+tag@domain.co.uk')).toBe(true);\n      expect(isValidEmail('user123@test-domain.org')).toBe(true);\n    });\n\n    it('should reject invalid email formats', () => {\n      expect(isValidEmail('invalid-email')).toBe(false);\n      expect(isValidEmail('user@')).toBe(false);\n      expect(isValidEmail('@domain.com')).toBe(false);\n      expect(isValidEmail('user@domain')).toBe(false);\n      expect(isValidEmail('')).toBe(false);\n      expect(isValidEmail(null)).toBe(false);\n    });\n  });\n\n  describe('validatePassword', () => {\n    it('should validate strong passwords', () => {\n      const result = validatePassword('StrongP@ssw0rd!');\n      expect(result.isValid).toBe(true);\n      expect(result.errors).toHaveLength(0);\n    });\n\n    it('should reject passwords that are too short', () => {\n      const result = validatePassword('Short1!');\n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Password must be at least 8 characters long');\n    });\n\n    it('should require lowercase letters', () => {\n      const result = validatePassword('PASSWORD123!');\n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Password must contain at least one lowercase letter');\n    });\n\n    it('should require uppercase letters', () => {\n      const result = validatePassword('password123!');\n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Password must contain at least one uppercase letter');\n    });\n\n    it('should require numbers', () => {\n      const result = validatePassword('Password!');\n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Password must contain at least one number');\n    });\n\n    it('should require special characters', () => {\n      const result = validatePassword('Password123');\n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Password must contain at least one special character');\n    });\n\n    it('should handle null/undefined passwords', () => {\n      expect(validatePassword(null).isValid).toBe(false);\n      expect(validatePassword(undefined).isValid).toBe(false);\n      expect(validatePassword('').isValid).toBe(false);\n    });\n\n    it('should return multiple errors for weak passwords', () => {\n      const result = validatePassword('weak');\n      expect(result.isValid).toBe(false);\n      expect(result.errors.length).toBeGreaterThan(1);\n    });\n  });\n\n  describe('generateSecureRandomString', () => {\n    it('should generate string of specified length', () => {\n      const result = generateSecureRandomString(16);\n      expect(result).toHaveLength(16);\n    });\n\n    it('should generate string of default length', () => {\n      const result = generateSecureRandomString();\n      expect(result).toHaveLength(32);\n    });\n\n    it('should generate different strings on multiple calls', () => {\n      const result1 = generateSecureRandomString(16);\n      const result2 = generateSecureRandomString(16);\n      expect(result1).not.toBe(result2);\n    });\n\n    it('should only contain valid characters', () => {\n      const result = generateSecureRandomString(100);\n      const validChars = /^[A-Za-z0-9]+$/;\n      expect(validChars.test(result)).toBe(true);\n    });\n  });\n\n  describe('RateLimiter', () => {\n    let rateLimiter;\n\n    beforeEach(() => {\n      rateLimiter = new RateLimiter(3, 1000); // 3 requests per second\n    });\n\n    it('should allow requests within limit', () => {\n      expect(rateLimiter.isAllowed('user1')).toBe(true);\n      expect(rateLimiter.isAllowed('user1')).toBe(true);\n      expect(rateLimiter.isAllowed('user1')).toBe(true);\n    });\n\n    it('should block requests exceeding limit', () => {\n      // Use up the limit\n      rateLimiter.isAllowed('user1');\n      rateLimiter.isAllowed('user1');\n      rateLimiter.isAllowed('user1');\n      \n      // This should be blocked\n      expect(rateLimiter.isAllowed('user1')).toBe(false);\n    });\n\n    it('should track different users separately', () => {\n      // Use up limit for user1\n      rateLimiter.isAllowed('user1');\n      rateLimiter.isAllowed('user1');\n      rateLimiter.isAllowed('user1');\n      \n      // user2 should still be allowed\n      expect(rateLimiter.isAllowed('user2')).toBe(true);\n    });\n\n    it('should return correct remaining requests', () => {\n      expect(rateLimiter.getRemainingRequests('user1')).toBe(3);\n      \n      rateLimiter.isAllowed('user1');\n      expect(rateLimiter.getRemainingRequests('user1')).toBe(2);\n      \n      rateLimiter.isAllowed('user1');\n      expect(rateLimiter.getRemainingRequests('user1')).toBe(1);\n      \n      rateLimiter.isAllowed('user1');\n      expect(rateLimiter.getRemainingRequests('user1')).toBe(0);\n    });\n\n    it('should reset after time window', (done) => {\n      const shortLimiter = new RateLimiter(1, 100); // 1 request per 100ms\n      \n      // Use up the limit\n      expect(shortLimiter.isAllowed('user1')).toBe(true);\n      expect(shortLimiter.isAllowed('user1')).toBe(false);\n      \n      // Wait for window to reset\n      setTimeout(() => {\n        expect(shortLimiter.isAllowed('user1')).toBe(true);\n        done();\n      }, 150);\n    });\n  });\n\n  describe('SecurityAuditLogger', () => {\n    let logger;\n\n    beforeEach(() => {\n      logger = new SecurityAuditLogger();\n      // Mock console.log to avoid test output\n      jest.spyOn(console, 'log').mockImplementation(() => {});\n    });\n\n    afterEach(() => {\n      console.log.mockRestore();\n    });\n\n    it('should log security events', () => {\n      logger.log(SECURITY_EVENTS.LOGIN_SUCCESS, 'user123', { ip: '192.168.1.1' });\n      \n      const logs = logger.getLogs();\n      expect(logs).toHaveLength(1);\n      expect(logs[0].event).toBe(SECURITY_EVENTS.LOGIN_SUCCESS);\n      expect(logs[0].userId).toBe('user123');\n      expect(logs[0].details.ip).toBe('192.168.1.1');\n      expect(logs[0].timestamp).toBeDefined();\n    });\n\n    it('should include user agent in logs', () => {\n      logger.log(SECURITY_EVENTS.LOGIN_FAILURE, 'user123');\n      \n      const logs = logger.getLogs();\n      expect(logs[0].userAgent).toBeDefined();\n    });\n\n    it('should handle multiple log entries', () => {\n      logger.log(SECURITY_EVENTS.LOGIN_SUCCESS, 'user1');\n      logger.log(SECURITY_EVENTS.LOGOUT, 'user1');\n      logger.log(SECURITY_EVENTS.LOGIN_SUCCESS, 'user2');\n      \n      const logs = logger.getLogs();\n      expect(logs).toHaveLength(3);\n    });\n\n    it('should clear logs', () => {\n      logger.log(SECURITY_EVENTS.LOGIN_SUCCESS, 'user1');\n      logger.log(SECURITY_EVENTS.LOGOUT, 'user1');\n      \n      expect(logger.getLogs()).toHaveLength(2);\n      \n      logger.clearLogs();\n      expect(logger.getLogs()).toHaveLength(0);\n    });\n\n    it('should return copy of logs to prevent mutation', () => {\n      logger.log(SECURITY_EVENTS.LOGIN_SUCCESS, 'user1');\n      \n      const logs = logger.getLogs();\n      logs.push({ fake: 'entry' });\n      \n      // Original logs should be unchanged\n      expect(logger.getLogs()).toHaveLength(1);\n    });\n  });\n\n  describe('SECURITY_EVENTS', () => {\n    it('should have all required event types', () => {\n      expect(SECURITY_EVENTS.LOGIN_SUCCESS).toBeDefined();\n      expect(SECURITY_EVENTS.LOGIN_FAILURE).toBeDefined();\n      expect(SECURITY_EVENTS.LOGOUT).toBeDefined();\n      expect(SECURITY_EVENTS.REGISTRATION).toBeDefined();\n      expect(SECURITY_EVENTS.PASSWORD_CHANGE).toBeDefined();\n      expect(SECURITY_EVENTS.UNAUTHORIZED_ACCESS).toBeDefined();\n      expect(SECURITY_EVENTS.SESSION_EXPIRED).toBeDefined();\n      expect(SECURITY_EVENTS.SUSPICIOUS_ACTIVITY).toBeDefined();\n      expect(SECURITY_EVENTS.DATA_ACCESS).toBeDefined();\n      expect(SECURITY_EVENTS.DATA_MODIFICATION).toBeDefined();\n    });\n  });\n});